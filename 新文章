当微软认识服务遇到微信APP
目录
前言：	1
ASP.NET WEBAPI实现微信接入验证	2
ASP.NET WEBAPI实现微信JS-SDK接口注入权限验证配置	5
ASP.NET获取微信客户端上传的图片	8
简单的文件处理	10
封装微软牛津计划API客户端	11
实现Face/ Detect	16
实现Face/ Verify	17
C#实现Mongodb开发	18
建立Models	20
改进Face/Detect	21
改进Face/Verify	25
设计微信客户端首页样式	29
设计微信客户端功能页样式	34
实现微信客户端交互	36
最后再说几句	41

前言：
微软牛津计划提供了一组基于Rest架构的API和SDK工具包，帮助开发者轻轻松松使用微软的自然数据理解能力为自己的解决方案增加智能服务。利用微软牛津计划构建你自己的解决方案，支持任意语言及任意开发平台。主要提供了4个自然语言处理方面的核心问题解决方案：
1）人脸识别：微软最先进的人脸算法，以云平台为基础，检测和识别图片中的人脸。为您的移动应用和桌面应用提供人脸算法的技术支持。
2）语音识别：Speech API为开发者提供最先进的语音处理算法。通过这些API，开发者可以轻松地为自己的应用添加语音操作功能。在一定条件下，这些API还可以实现与用户之间的实时交互。
3）计算机视觉：Computer Vision APIs为开发者提供最顶尖的图像处理算法。通过这些API你可以获得基于图像视觉内容的各种信息并生成理想的缩略图。
4）语言理解智能服务：语言理解智能服务(LUIS)用快速有效的方式帮助开发者在应用中增加语言理解能力。通过LUIS你可以使用已经构建好的世界顶级模型。如果你有专门的需求，LUIS也可以指导你快速创建自己的模型。
微软提供了这么强大的API，我第一时间就想，是不是可以迁移到微信平台上去做一些好玩的应用，不过在这之前，我没有做过任何微信开发的工作，所以本篇文章将分享整个实现的经验。
这个系列中会涉及到的技术有
	ASP.NET WEBApi
	微软牛津计划API使用
	HttpClient使用
	WebAPI编程
	RouteAttribute
	微信WeUI框架使用
	微信开发配置
	微信JS-SDK使用
	ASP.NET WEBApi和微信接口配合
	MongoDB（NoSQL）


ASP.NET WEBAPI实现微信接入验证
首先你需要一个微信公众号，很重要的是你需要完成认证，这点非常重要，如果不认证优先功能无法实现。
当你完成公众号的基本设定后，我们需要为开发做第一件事情：基本配置。下面我摘抄了微信开发文档中关于接入指南的部分图文
登录微信公众平台官网后，在公众平台后台管理页面 - 开发者中心页，点击“修改配置”按钮，填写服务器地址（URL）、Token和EncodingAESKey，其中URL是开发者用来接收微信消息和事件的接口URL。Token可由开发者可以任意填写，用作生成签名（该Token会和接口URL中包含的Token进行比对，从而验证安全性）。EncodingAESKey由开发者手动填写或随机生成，将用作消息体加解密密钥。

同时，开发者可选择消息加解密方式：明文模式、兼容模式和安全模式。模式的选择与服务器配置在提交后都会立即生效，请开发者谨慎填写及选择。加解密方式的默认状态为明文模式，选择兼容模式和安全模式需要提前配置好相关加解密代码，详情请参考消息体签名及加解密部分的文档。

 

微信的意思是，我们需要有一台服务器接收微信发出的一个GET请求，然后验证后返回，如果这个流程走通了，则说明你指定的服务器是有效的，这好像有点手机短信验证码通过的意思。
那么微信将GET我们什么数据呢？
开发者提交信息后，微信服务器将发送GET请求到填写的服务器地址URL上，GET请求携带四个参数：
参数	描述
signature	微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。
timestamp	时间戳
nonce	随机数
echostr	随机字符串
开发者通过检验signature对请求进行校验（下面有校验方式）。若确认此次GET请求来自微信服务器，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。

但是关于服务器的验证逻辑的实现，微信没有给出ASP.NET的实现，只给了PHP的，网上有些分享是使用了ASP.NET MVC的方案，但我需要做一个WEBAPI，所以花了点时间研究了下，下面是已经验证通过的WEBAPI的代码实现
我定义了一个类：WeixinController，从ApiController继承，这个WEBAPI将提供所有微信的服务，包括现在的接入验证后后期需要的各种微软服务。

WeixinController提供了一个Get服务，实现如下

public HttpResponseMessage Get(string signature, string timestamp, string nonce, string echostr)
{
    string[] ArrTmp = { TOKEN, timestamp, nonce };
    Array.Sort(ArrTmp);
    string tmpStr = string.Join("", ArrTmp);
    var result = FormsAuthentication.HashPasswordForStoringInConfigFile(tmpStr, "SHA1").ToLower();

    return new HttpResponseMessage (){ 
        Content = new StringContent(result, Encoding.GetEncoding("UTF-8"), "application/x-www-form-urlencoded") 
    };
}

这个Get按微信的要求接受四个参数：signature、timestamp、nonce和echostr，然后将这四个参数进行排序后，连接为一个字符串并进行SHA1加密。上面这段代码的要点是返回值，很多工程师在使用WEBAPI返回给微信验证的时候一直失败，是因为忽略了返回值的编码要求是application/x-www-form-urlencoded。
现在你去公众平台后台管理页面 - 开发者中心页点击提交，过一会会收到验证通过的消息，注意：微信公众号接口只支持80接口



ASP.NET WEBAPI实现微信JS-SDK接口注入权限验证配置
我们的客户端是一个HTML5客户端，我们计划采用微信提供的JS-SDK，但是所有需要使用JS-SDK的页面必须先注入配置信息，否则将无法调用，配置的代码如
wx.config({
    debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。
    appId: '', // 必填，公众号的唯一标识
    timestamp: , // 必填，生成签名的时间戳
    nonceStr: '', // 必填，生成签名的随机串
    signature: '',// 必填，签名，见附录1
    jsApiList: [] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2
});

当我们使用JS-SDK的时候，微信会将以上的参数进行加密和验算是否正确，所以我们需要提供一个正确的签名值。
需要获得这个签名必须要完成两步，下面的UML描述了这个过程

 

第一步：获取access token
access_token是公众号的全局唯一票据，公众号调用各接口时都需使用access_token。开发者需要进行妥善保存。access_token的存储至少要保留512个字符空间。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。
微信提供接口为
https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET

参数说明
参数	是否必须	说明
grant_type	是	获取access_token填写client_credential
appid	是	第三方用户唯一凭证
secret	是	第三方用户唯一凭证密钥，即appsecret


我们用于实现获取access token的WEBAPI代码为

if (HttpRuntime.Cache["access_token"] == null)
{
    var queryString = HttpUtility.ParseQueryString(string.Empty);
    queryString["grant_type"] = "client_credential";
    queryString["appid"] = APPID;
    queryString["secret"] = APPSECRET;

    var uri = "https://api.weixin.qq.com/cgi-bin/token?" + queryString;

    HttpResponseMessage response;
    response = await client.GetAsync(uri);
    var msg = await response.Content.ReadAsStringAsync();
    var jsonobj = Newtonsoft.Json.Linq.JObject.Parse(msg);

    HttpRuntime.Cache.Add("access_token",
        (string)jsonobj["access_token"],
        null,
        DateTime.Now.AddMinutes((int)jsonobj["expires_in"]),
        new TimeSpan(0, 0, 0),
        System.Web.Caching.CacheItemPriority.AboveNormal,
        null
        );
}

为了遵循微信关于缓存的要求，我们采用了HttpRuntime.Cache来保存token。正确获取到access token后，我们需要以此来获取jsapi_ticket

第二步：获取jsapi_ticket
jsapi_ticket是公众号用于调用微信JS接口的临时票据。正常情况下，jsapi_ticket的有效期为7200秒，通过access_token来获取。由于获取jsapi_ticket的api调用次数非常有限，频繁刷新jsapi_ticket会导致api调用受限，影响自身业务，开发者必须在自己的服务全局缓存jsapi_ticket 。

我们用于获取jsapi_ticket的代码为

if (HttpRuntime.Cache["jsapi_ticket"] == null)
{
    var queryString = HttpUtility.ParseQueryString(string.Empty);
    queryString["access_token"] = (string)HttpRuntime.Cache["access_token"];
    queryString["type"] = "jsapi";

    var uri = "https://api.weixin.qq.com/cgi-bin/ticket/getticket?" + queryString;

    HttpResponseMessage response;
    response = await client.GetAsync(uri);
    var msg = await response.Content.ReadAsStringAsync();
    var jsonobj = Newtonsoft.Json.Linq.JObject.Parse(msg);

    HttpRuntime.Cache.Add("jsapi_ticket",
                        (string)jsonobj["ticket"],
                        null,
                        DateTime.Now.AddMinutes((int)jsonobj["expires_in"]), 
                        new TimeSpan(0, 0, 0), 
                        System.Web.Caching.CacheItemPriority.AboveNormal, 
                        null
                        );
}

同样是为了遵循信关于缓存的要求，我们采用了HttpRuntime.Cache来保存jsapi_ticket。现在，我们用于签名的素材都到齐了，我们要实现签名算法了。先看下微信关于签名算法的要求：
步骤1. 对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，使用URL键值对的格式（即key1=value1&key2=value2…）拼接成字符串string1：
步骤2. 对string1进行sha1签名，得到signature：
这个步骤1的排序其实是可以忽略的，签名字段的排序其实是：jsapi_ticket、noncestr、timestamp、url就可以了，实现的代码如下

var pwd = string.Format("jsapi_ticket={0}&noncestr={1}&timestamp={2}&url={3}",
    (string)HttpRuntime.Cache["jsapi_ticket"],
    noncestr,
    timestamp,
    url
    );

var tmpStr = FormsAuthentication.HashPasswordForStoringInConfigFile(pwd, "SHA1");

return Request.CreateResponse(HttpStatusCode.OK, tmpStr);

这时候我们前端的HTML5就可以正确的采用JS-SDK了。


ASP.NET获取微信客户端上传的图片
本来我以为这个是很简单的事情，后来做了才发现原来使用微信JS-SDK的时候，微信的HTML5客户端不会将图片直接post给我服务端，而是先提交给微信服务器，然后我的服务端需要通过serverId 来获得图片，大致的流程我绘制了UML，大家可以理解下

 

目前我们只关心服务器这段，我们将得到客户端传来的ServerID，从微信的服务器上下载图片到本地。
需要实现这一点，我们有两个前提
	公众号要注册，要给钱，这就是前面强调需要完成的的认证的原因
	获取access token

我们实现的代码如下

public async Task<string> Get(string mediaid)
{
    var queryString = HttpUtility.ParseQueryString(string.Empty);
    queryString["access_token"] = await Get();
    queryString["media_id"] = mediaid;

    var uri = "http://file.api.weixin.qq.com/cgi-bin/media/get?" + queryString;

    HttpResponseMessage response;
    response = await client.GetAsync(uri);

    var msg = await response.Content.ReadAsStreamAsync();
    var file = response.Content.Headers.ContentDisposition.FileName.Replace("\"", "");

    var helper = new ProjecToxfordClientHelper();

    var content = await FileHelper.ReadAsync (msg);

    FileHelper.SaveFile(content, file);

    return file;
}

如果access token正确且media_id（就是那个serverid）有效，微信服务端会返回给我们文件名和流，我们就可以对这些流做一些我们希望的处理了。

好了，到了现在的话，我们对微信服务器需要实现的接口都差不多了，接下来我们需要实现牛津计划的FACE了。


简单的文件处理
你应该注意到了，我们这个应用需要进行图片流的处理，进行本地存储读写，所以我们还是有必要封装一个FileHelper来实现，当然网上有很多开源的优秀代码，我只是简单的写了一个Helper

我们的总体文件存储目录在配置文件中定义
private static string photofolder = System.Configuration.ConfigurationManager.AppSettings["ProjecToxfordPhotos"];

我们提供两种读取文件的方法
从存储中读取文件
public static async Task<byte[]> ReadAsync(string fileName)
{
    var filePath = Path.Combine(photofolder, fileName);
    var fs = File.OpenRead(filePath);
    int filelength = (int)fs.Length;
    var image = new Byte[filelength];
    await fs.ReadAsync(image, 0, filelength);
    fs.Close();
    return image;
}

从流中读取文件
public static async Task<byte[]> ReadAsync(Stream stream)
{
    var result = new byte[(int)stream.Length];
    await stream.ReadAsync(result, 0, (int)stream.Length);
    stream.Close();
    return result;
}


当然还有保存文件的方法
public static void SaveFile(byte[] content, string fileName)
{
    var filePath = Path.Combine(photofolder, fileName);

    FileStream fs = new FileStream(filePath, FileMode.Create);
    BinaryWriter bw = new BinaryWriter(fs);
    bw.Write(content);
    bw.Close();
    fs.Close();
}

是的，我们还需要删除的方法，当用户从微信端上传的照片我们从微信服务器下载后发现从该照片中无法有效的辨识出Face，我们需要将其从文件服务器中删除。
public static void Delete(string fileName)
{
    var filePath = Path.Combine(photofolder, fileName);
    File.Delete(filePath);
}



封装微软牛津计划API客户端

牛津计划的API是由一个基础Url、服务名称、参数组成为的服务，大多是POST（我还没有完全看完），这些参数多是字符串，但也有流格式(比如上传图片什么的)，我们的ProjecToxfordClientHelper就是计划将牛津API的实现进行封装，为我们不同的APIController提供服务。
我们先定义一些基本的字段

private const string serviceHost = "https://api.projectoxford.ai/face/v1.0";
private const string KEY = "";
private HttpClient client;
private static string photofolder = System.Configuration.ConfigurationManager.AppSettings["ProjecToxfordPhotos"];

serviceHost就是牛津的API，KEY你可以通过注册牛津开发计划来获得，photofolder是保持我们需要上传图所在的位置。
我们在构造函数中初始化HttpClient，为HttpClient添加两个必须的头标识。


public ProjecToxfordClientHelper()
{
    client = new HttpClient();
    var queryString = HttpUtility.ParseQueryString(string.Empty);
    client.DefaultRequestHeaders.Add("ContentType", "application/json");
    client.DefaultRequestHeaders.Add("Ocp-Apim-Subscription-Key", KEY);
}

接下来，我们要实现两种POST的提交，一种是提交流参数，一种是提交字符串参数

实现提交字符串参数的POST

public async Task<ProjecToxfordResponseModels> PostAsync(string querkey, object body, Dictionary<string, string> querystr = null)
{
    var queryString = HttpUtility.ParseQueryString(string.Empty);
    if (querystr != null)
    {
        foreach (var entry in querystr)
        {
            queryString[entry.Key] = entry.Value;
        }
    }
    var uri = string.Format("{0}/{1}?{2}", serviceHost, querkey, queryString);

    var jsonStr = Newtonsoft.Json.JsonConvert.SerializeObject(body);
    byte[] byteData = Encoding.UTF8.GetBytes(jsonStr);

    HttpResponseMessage response;
    using (var content = new ByteArrayContent(byteData))
    {
        content.Headers.ContentType = new MediaTypeHeaderValue("application/json");
        response = await client.PostAsync(uri, content);
        var msg = await response.Content.ReadAsStringAsync();
        return new ProjecToxfordResponseModels(msg, response.StatusCode);
    }
}

所谓的字符串参数就是将实现Fields的对象以JSON格式序列化，然后POST给牛津API。
var jsonStr = Newtonsoft.Json.JsonConvert.SerializeObject(body);
byte[] byteData = Encoding.UTF8.GetBytes(jsonStr);

所以要记得content的内容类型要定义为
content.Headers.ContentType = new MediaTypeHeaderValue("application/json");


那类似图片这些流文件不能采用这个方法，所以我们重载了一个方法

public async Task<ProjecToxfordResponseModels> PostAsync(string querkey, byte[] body, Dictionary<string, string> querystr = null)
{
    var queryString = HttpUtility.ParseQueryString(string.Empty);
    if (querystr != null)
    {
        foreach (var entry in querystr)
        {
            queryString[entry.Key] = entry.Value;
        }
    }

    var uri = string.Format("{0}/{1}?{2}", serviceHost, querkey, queryString);

    HttpResponseMessage response;
    using (var content = new ByteArrayContent(body))
    {
        content.Headers.ContentType = new MediaTypeHeaderValue("application/octet-stream");
        response = await client.PostAsync(uri, content);
        var msg = await response.Content.ReadAsStringAsync();
        return new ProjecToxfordResponseModels(msg, response.StatusCode);
    }
}

看下参数，流格式的内容需要以Byte数组的方式进行传递，但实际的处理中没有什么太大的不同，如果传递的是Byte数组就直接处理，否则先序列化为Byte数组，但是要注意的是，流媒体的json的编码是不同的，

 



所以我们优化下代码为

public async Task<ProjecToxfordResponseModels> PostAsync(string querkey, object body, Dictionary<string, string> querystr = null)
{
    var queryString = HttpUtility.ParseQueryString(string.Empty);
    if (querystr != null)
    {
        foreach (var entry in querystr)
        {
            queryString[entry.Key] = entry.Value;
        }
    }
    var uri = string.Format("{0}/{1}?{2}", serviceHost, querkey, queryString);

    byte[] byteData = null;

    if (body.GetType() == typeof(byte[]))
    {
        byteData = (byte[])body;
    }
    else
    {
        var jsonStr = Newtonsoft.Json.JsonConvert.SerializeObject(body);
        byteData = Encoding.UTF8.GetBytes(jsonStr);
    }

    HttpResponseMessage response;
    using (var content = new ByteArrayContent(byteData))
    {
        content.Headers.ContentType = body.GetType() == typeof(byte[]) ? 
            new MediaTypeHeaderValue("application/octet-stream") : 
            new MediaTypeHeaderValue("application/json");
        response = await client.PostAsync(uri, content);
        var msg = await response.Content.ReadAsStringAsync();
        return new ProjecToxfordResponseModels(msg, response.StatusCode);
    }
}


我们再提供一个帮助处理牛津API返回值的方法

public HttpResponseMessage CreateHttpResponseMessage(HttpRequestMessage request, ProjecToxfordResponseModels result)
{
    if (result.StatusCode == HttpStatusCode.OK)
    {

        return request.CreateResponse(HttpStatusCode.OK, result.Message);
    }
    else
    {
        return request.CreateErrorResponse(result.StatusCode, result.Message);
    }
}



实现Face/ Detect

Detect服务接受一个上传的图片，并且识别其中的人脸，如果找不到人脸则返回一个空的数组，否则返回人脸数据的数组，这些人脸数据包含了：FaceID、性别、年龄、微笑值、胡须情况等。
当我们上传了一张有效照片之后，牛津计划会返回给我们对照片中每一个识别成功的人脸的FaceID，这个ID很重要，当我们需要再次了解照片中人脸的信息，我们不必再次上传照片，直接提交这个FaceID即可。
还记得我们说过微信客户端上传的图片是不能直接POST到我们WebAPI服务端的，必须我们从微信服务器去下载照片，然后上传给牛津API，所以我们的代码需要如下实现

[HttpGet]
[Route("face/detect/{weixnmediaid}")]
public async Task<HttpResponseMessage> Detect(string weixnmediaid)
{
    var key = "detect";

    var file = await new WeixinController().Get(weixnmediaid);

    var content = FileHelper.ReadAsync (file);

    if (content != null)
    {
        var result = await client.PostAsync(key,
            content,
            new Dictionary<string, string> {
            {"returnFaceId","true"},
            {"returnFaceLandmarks","flase"},
            }
            );

        return client.CreateHttpResponseMessage(Request, result);
    }
    throw new HttpResponseException(HttpStatusCode.BadRequest);
}

在这里我用了RouteAttribute，微软的ASP.NET WEBAPI的RouteAttribute太好用了，我们可以将路由设计为非常友好的状态，而不用设计为带参数的url，现在我们的API看上去高大上多了。
不过呢，这个是微信的模式，如果我们想做一个标准的网站用input file的组件上传照片，那我们怎么实现呢？如下代码告诉你怎么做了


private static string uploadedImageFiled = System.Configuration.ConfigurationManager.AppSettings["UploadedImage"];

[HttpPost]
[Route("face/detect")]
public async Task<HttpResponseMessage> Detect()
{
    var key = "detect";

    var httpPostedFile = HttpContext.Current.Request.Files[uploadedImageFiled];
    if (httpPostedFile != null)
    {
        var content = await FileHelper.ReadAsync (httpPostedFile.InputStream);

        var result = await client.PostAsync(key,
            content,
            new Dictionary<string, string> {
            {"returnFaceId","true"},
            {"returnFaceLandmarks","flase"},
            }
            );
        FileHelper.SaveFile(content, httpPostedFile.FileName);

        return client.CreateHttpResponseMessage(Request, result);
    }
    throw new HttpResponseException(HttpStatusCode.BadRequest);
}

这段代码的采用的是POST，URL进过RouteAttribute优化后不需要带任何参数，API从HttpContext.Current.Request.Files获取上传的图片进行处理。

现在我们封装了Face/ Detect服务了，可以提供微信客户端和PC浏览器客户端的服务了。


实现Face/ Verify

Verify是非常好玩的服务，他可以对比两张人脸是否一致，或者相似度多少。牛津的VerifyAPI比较简单，POST两个FaceID即可得到一个结果，所以我们的封装也很简单。

[HttpGet]
[Route("face/verify/{faceId1}/{faceId2}")]
public async Task<HttpResponseMessage> Verify(string faceId1, string faceId2)
{
    var key = "verify";

    var result = await client.PostAsync(
           key,
            new
            {
                faceId1 = faceId1,
                faceId2 = faceId2
            }
           );

    return client.CreateHttpResponseMessage(Request,result);
}

你可以看到，同样因为采用了RouteAttribute了，我们的Url非常优雅，值得注意的是我们的API提供的是Get，至少我们调试方便了很多，不是吗？



C#实现Mongodb开发
其实在项目的前期，我完全没有想到需要使用数据库，但是随着完成了Face/ Detect和Face/ Verify的封装后，我发现显然数据库是必须的，原因是：牛津的FaceAPI是收费的，当客户端每次调用的使用，都会消耗我们的宝贵资源，所以我们希望在如下的情况下用户的请求不必再次访问牛津FaceAPI
	用户刷新页面时，不需要重新访问牛津FaceAPI
	当用户分享自己的测试结果，其他用户访问这个页面时，不必对同样的照片计算再次提交给牛津API
那么为什么我们不采用SQL Server呢？因为我们保存的是每次牛津的计算结果，这些结果之间没有任何关系型需求，我们不需要事务处理，我们需要查询效率极高，而且很重要的是：我们保存的牛津计算结果是JSON格式的数据，结合以上需求，显然采用Mongo是明智的选择。
从Mongo的官网下载Windos64bit的安装文件，配置数据文件位置和日志文件位置，安装mongo服务

mongod --dbpath="C:\mongoDb\data" --logpath="C:\mongoDb\log\mongodb.log" –install
启动服务
Net start ‘mongdb’
访问你的http://localhost:27017/检查服务是否正确启动了。

目前我们的应用不需要删除和修改，只是追加和查询，所以我们可以写一个简单的MongoDBHelper来帮助我们使用MongoDB
服务器链接和数据库名字都采用配置文件定义

private static string mongoDbServer = ConfigurationManager.ConnectionStrings["mongoConnection"].ConnectionString;
private static string mongoDbName = ConfigurationManager.AppSettings["mongoDb"];

private IMongoClient client;
private IMongoDatabase database;
private IMongoCollection<T> collection;

操作MongoDB可以强类型和弱类型，当然我们会选择使用强类型不但代码更加健壮，性能也会更好。实例化Helper时设定集合的名称，构造函数中的T表示了我们用泛型来实现强类型的MongoDb的操作。

public MongoDBHelper(string collectionName)
{
    client = new MongoClient(mongoDbServer);
    database = client.GetDatabase(mongoDbName);
    collection = database.GetCollection<T>(collectionName);
}

目前我们提供的操作非常简单，只有插入和查询，不提供删除和修改

public async Task InsertAsync(T document)
{
    await collection.InsertOneAsync(document);
}


public async Task InsertAsync(IEnumerable<T> documents)
{
    await collection.InsertManyAsync(documents);
}

public async Task<T> SelectOneAsync(Expression<Func<T, bool>> func)
{
    return await collection.Find<T>(func).FirstOrDefaultAsync();
}

public async Task<List<T>> SelectMore(Expression<Func<T, bool>> func)
{
    return await collection.Find(func).ToListAsync();
}


建立Models

因为我们的MongoDB的操作是强类型，所以我们必须为涉及到的数据源建立Models。

存储微信服务器得到的MediaID和本地文件名关系的WeixinImgFileModels

public class WeixinImgFileModels
{
    public ObjectId _id { set; get; }
    public string MediaId { set; get; }
    public string FileName { set; get; }

}

存储本地文件名和Face识别数据关系的DetectResultModels

public class DetectResultModels
{
    public ObjectId _id { set; get; }
    public string faceId { set; get; }
    public string FileName { set; get; }
    public double Age { set; get; }
    public string Gender { set; get; }
    public double Smile { set; get; }

}


存储一对FaceID的比较结果

public class VerifyModels
{
    public ObjectId _id { set; get; }

    public string FaceID1 { set; get; }

    public string FaceID2 { set; get; }

    public double Confidence { set; get; }

    public bool IsIdentical { set; get; }

}


改进Face/Detect

现在Face/Detect和Face/Verify将支持将用户提交的结果持久化。我们先考虑下Face/Detect现在的变化，原先我们的流程是：从微信客户端获得mediaID，通过这个mediaID从微信服务器下载图片，然后将这个图片提交给牛津，以获得FaceID
 



现在我们需要考虑的更周到了：当从微信客户端得到mediaID，我们需要查看下本地文件夹中是否有匹配的文件，在提交给牛津之前我们也需要从Mango数据库中查询是否有匹配的上次的提交结果
 

我们先改进微信服务的代码，使得只有Mongo没有存储mediaID和对应的文件再从微信的服务器去下载图片

public async Task<string> Get(string mediaid)
{
    var mongo = new MongoDBHelper("weixinImgFile");

    //查询mongo中是否存储了mediaid对应的照片文件
    var doc = await mongo.SelectOneAsync(x => x["mediaid"] == mediaid);
    if (doc != null)
    {
        return doc["filename"].ToString();
    }

    //http://file.api.weixin.qq.com/cgi-bin/media/get?access_token=ACCESS_TOKEN&media_id=MEDIA_ID
    var queryString = HttpUtility.ParseQueryString(string.Empty);
    queryString["access_token"] = await Get();
    queryString["media_id"] = mediaid;

    var uri = "http://file.api.weixin.qq.com/cgi-bin/media/get?" + queryString;

    HttpResponseMessage response;
    response = await client.GetAsync(uri);

    var msg = await response.Content.ReadAsStreamAsync();
    var fileName = response.Content.Headers.ContentDisposition.FileName.Replace("\"", "");

    var helper = new ProjecToxfordClientHelper();

    var content = await FileHelper.ReadAsync(msg);

    FileHelper.SaveFile(content, fileName);

    await mongo.InsertAsync(Newtonsoft.Json.JsonConvert.SerializeObject(
        new {
            Mediaid = mediaid,
            FileName = fileName
        }
        ));

    return fileName;
}


然后我们来改进FaceController的DetectAPI，使得先在Mongo中查询对应照片的分析结果，当没有之前查询的结果，再去牛津进行分析。
[HttpGet]
[Route("face/detect/{weixnmediaid}")]
public async Task<HttpResponseMessage> Detect(string weixnmediaid)
{
    var key = "detect";

    //得到从微信服务器下载的文件名
    var fileName = await new WeixinController().Get(weixnmediaid);

    var mongo = new MongoDBHelper<DetectResultModels>("facedetect");

    //照片之前有没有下载过
    var docArr = await mongo.SelectMoreAsync(x => x.FileName == fileName);
    if (docArr.Count > 0)
    {
        var resultJson = docArr.Select(
            doc => new
            {
                faceId = doc.faceId,
                filename = doc.FileName,
                age = doc.Age,
                gender = doc.Gender,
                smile = doc.Smile
            }
            ).ToJson();

        return client.CreateHttpResponseMessage(
            Request,
            new Models.ProjecToxfordResponseModels(resultJson, HttpStatusCode.OK));
    }
    //如果Mongo中没有该照片对应的Face信息
    var content = await FileHelper.ReadAsync(fileName);

    if (content != null)
    {
        var result = await client.PostAsync(key,
            content,
            new Dictionary<string, string> {
            {"returnFaceId","true"},
            {"returnFaceLandmarks","flase"},
            {"returnFaceAttributes","age,gender,smile"}
            }
            );

        if (result.StatusCode == HttpStatusCode.OK)
        {
            var tmpJArr = Newtonsoft.Json.Linq.JArray.Parse(result.Message);
            //将牛津结果写入数据库
            foreach (var tmp in tmpJArr)
            {
                await mongo.InsertAsync(new DetectResultModels()
                {
                    FileName = fileName,
                    faceId = (string)tmp["faceId"],
                    Age = (double)tmp["faceAttributes"]["age"],
                    Gender = (string)tmp["faceAttributes"]["gender"],
                    Smile = tmp["faceAttributes"]["smile"] != null ? (double)tmp["faceAttributes"]["smile"] : 0
                });
            }
            var resultJson = tmpJArr.Select(x => new
              {
                  faceId = x["faceId"],
                  age = (double)x["faceAttributes"]["age"],
                  gender = (string)x["faceAttributes"]["gender"],
                  smile = x["faceAttributes"]["smile"] != null ? (double)x["faceAttributes"]["smile"] : 0
              }).ToJson();

            return client.CreateHttpResponseMessage(
                Request,
                new Models.ProjecToxfordResponseModels(resultJson, HttpStatusCode.OK));
        }
    }
    throw new HttpResponseException(HttpStatusCode.BadRequest);
}
改进Face/Verify
face/verify的逻辑要简单的多，因为不需要涉及到第三方微信的服务，我们原先的逻辑是每次将得到的Face1ID和Face2ID提交给牛津以得到结果

 

现在我们将先查询mongo数据库，如果存储了之前的结果我们就直接返回，否则提交给牛津服务器。但是我们在查询结果的时候需要注意，每次客户端给我们的face1id和face2id不一定是相同的次序，所以要解决这个问题，我们有两种办法
	查询的时候两种次序排列都查询一次
	存储的时候两种次序排列都存储一次
考虑到查询性能，我选择存储冗余，在存储的时候把两种排列次序都存储一次。
 

按上面的思路，我们对代码做了修改

[HttpGet]
[Route("face/verify/{faceId1}/{faceId2}")]
public async Task<HttpResponseMessage> Verify(string faceId1, string faceId2)
{
    var key = "verify";

    var mongo = new MongoDBHelper<VerifyModels>("faceverify");

    //先检查数据库中是否有上次比较的结果
    var doc = await mongo.SelectOneAsync(x =>
        (x.FaceID1 == faceId1 && x.FaceID2 == faceId2)
        );
    if (doc != null)
    {
        var mongoResult = new
        {
            faceID1 = doc.FaceID1,
            faceID2 = doc.FaceID2,
            confidence = doc.Confidence,
            isIdentical = doc.IsIdentical
        }.ToJson();

        return client.CreateHttpResponseMessage(
            Request,
            new Models.ProjecToxfordResponseModels(mongoResult, HttpStatusCode.OK));
    }

    //如果之前的结果没有查询到，则提交牛津查询
    var result = await client.PostAsync(
           key,
            new
            {
                faceId1 = faceId1,
                faceId2 = faceId2
            }
           );

    if (result.StatusCode == HttpStatusCode.OK)
    {

        var tmp = Newtonsoft.Json.Linq.JObject.Parse(result.Message);
        //如果为了加速查询的话，我们采用两次写入
        await mongo.InsertAsync(new VerifyModels()
        {
            FaceID1 = faceId1,
            FaceID2 = faceId2,
            Confidence = (double)tmp["confidence"],
            IsIdentical = (bool)tmp["isIdentical"]
        });

        await mongo.InsertAsync(new VerifyModels()
        {
            FaceID1 = faceId2,
            FaceID2 = faceId1,
            Confidence = (double)tmp["confidence"],
            IsIdentical = (bool)tmp["isIdentical"]
        });

        var resultJson = new
        {
            faceID1 = faceId1,
            faceID2 = faceId2,
            confidence = (double)tmp["confidence"],
            isIdentical = (bool)tmp["isIdentical"]
        }.ToJson();

        return client.CreateHttpResponseMessage(
            Request,
            new Models.ProjecToxfordResponseModels(resultJson, HttpStatusCode.OK));
    }
    return client.CreateHttpResponseMessage(Request, result);
}


设计微信客户端首页样式

WeUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信内网页开发量身设计，可以令用户的使用感知更加统一。在微信网页开发中使用 WeUI，有如下优势：
	同微信客户端一致的视觉效果，令所有微信用户都能更容易地使用你的网站
	便捷获取快速使用，降低开发和设计成本
	微信设计团队精心打造，清晰明确，简洁大方
该样式库目前包含 button、cell、dialog、progress、toast、article、icon 等各式元素，我们可以在https://github.com/weui/weui获得源代码和DEMO

·我们需要引入两个样式表：weui.css和example.css，不过example.css中有一个样式我们要简单的修改下，修改example.cs中的page类
.page {
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
}

我们先做首页，以了解WeUI样式库的使用方式。



建立Index.html引入样式库和配置head节点
<head>
<meta charset="utf-8">
<title>脸探</title>
<meta name="viewport"   content="initial-scale=1.0,user-scalable=no,maximum-scale=1,width=device-width"  /> 
<link href="css/weui.css" rel="stylesheet" />
<link href="css/example.css" rel="stylesheet" />

</head>
Body节点下的直接子元素是<div class="page">，其他所有元素都在这个节点下，我们的Index设计了两个div元素分别是
<div class="hd">
<div class="bd">
hd节点下的代码非常简单，就是title的描述
<h1 class="page_title">脸探</h1>
<p class="page_desc">测测脸的相似度</p>

bd包含的是一个<div class="weui_panel weui_panel_access">，WeUI提供的Panel非常容易设计图文组合列表，WeUI提供了一系列很有用的类：weui_panel、weui_panel_access、weui_panel_hd、weui_panel_bd

我们的Panel的标题就可以用weui_panel_hd进行修饰
<div class="weui_panel_hd">
具体的内容可以被weui_panel_bd修饰。
<div class="weui_panel_bd">

weui_panel_bd 的子元素如下
<a href="" class=" weui_media_box weui_media_appmsg ">
    <div class=" weui_media_hd">
        <img src="img/4432144_111855038929_2.jpg" alt="">
</div>
<div class=" weui_media_bd">
	    <h4 class=" weui_media_title ">标题</h4>
        <p class="weui_grid_label">内容 </p>
</div>
    
</a>


了解了如何布局一个列表项，那首页就容易完成了，代码如下
<div class="page">
    <div class="hd">
        <h1 class="page_title">脸探</h1>
        <p class="page_desc">测测脸的相似度</p>
    </div>
    <div class="bd">
        <div class="weui_panel weui_panel_access">
            <div class="weui_panel_hd">娃像谁</div>
            <div class="weui_panel_bd">
                <a href="family.html" class="weui_media_box weui_media_appmsg">
                    <div class="weui_media_hd">
                        <img class="weui_media_appmsg_thumb" src="fonts/family.jpg" alt="">
                    </div>
                    <div class="weui_media_bd">
                        <h4 class="weui_media_title">三人照</h4>
                        <p class="weui_media_desc">上传一家三口三人照，立即知道孩子与父母相像指数</p>
                    </div>
                </a>
                <a href="family3.html" class="weui_media_box weui_media_appmsg">
                    <div class="weui_media_hd">
                        <img class="weui_media_appmsg_thumb" src="fonts/one.jpg" alt="">
                    </div>
                    <div class="weui_media_bd">
                        <h4 class="weui_media_title">单人照</h4>
                        <p class="weui_media_desc">上传一家三口各自照片，立即知道孩子与父母相像指数</p>
                    </div>
                </a>
            </div>
        </div>
    </div>
    <div class="bd">
        <div class="weui_panel weui_panel_access">
            <div class="weui_panel_hd">夫妻相</div>
            <div class="weui_panel_bd">
                <a href="couple2.html" class="weui_media_box weui_media_appmsg">
                    <div class="weui_media_hd">
                        <img class="weui_media_appmsg_thumb" src="fonts/couple.jpg" alt="">
                    </div>
                    <div class="weui_media_bd">
                        <h4 class="weui_media_title">双人照</h4>
                        <p class="weui_media_desc">上传你和TA的双人照，你立即知道你们的天生缘分指数</p>
                    </div>
                </a>
                <a href="couple.html" class="weui_media_box weui_media_appmsg">
                    <div class="weui_media_hd">
                        <img class="weui_media_appmsg_thumb" src="fonts/one.jpg" alt="">
                    </div>
                    <div class="weui_media_bd">
                        <h4 class="weui_media_title">单人照</h4>
                        <p class="weui_media_desc">上传你们两人各自照片，你立即知道你们的天生缘分指数</p>
                    </div>
                </a>
            </div>
        </div>
    </div>
</div>

我们得到的首页效果大致如下
 



设计微信客户端功能页样式
以娃像谁-单人照的页面为例

页面代码如下

<div class="pic_panel">
    <div class="parent" id="parent1">
        <i class="icon iconfont icon-210 human"></i>
    </div>
    <div class="parent" id="parent2">
        <i class="icon iconfont icon-nv human"></i>
    </div>
    <div class="clear"></div>
    <div class="parent1like like"></div>
    <div class="parent2like like"></div>
    <div class="clear"></div>
    <div class="picture" id="child">
        <i class="icon iconfont icon-child human"></i>
    </div>
    <form>
        <input type="button" class="next" id="uploadImage" value="GO !!!">
    </form>
</div>
id="parent1" 和 id="parent2" 为存放父母照片的容器，id="child"为存放孩子照片的容器，点击容器触发选择照片，选择完成点击按钮作作比较。class="parent1like"和class="parent2like" 分别显示 id="child"分别与id="parent1"和id="parent2" 对比的结果。

我们得到的页面效果类似
 


实现微信客户端交互
在之前我们写了一个WebAPI接口来实现微信JS-SDK接口注入权限验证配置，现在我们的客户端需要调用这个接口来做验证了。客户端你需要引用jweixin-1.0.0.js
只要我们的业务需要使用微信JS-SDK，则都需要完成接口注入的权限验证，验证的方式我们来一步步分析。

 

页面将noncestr（这个可以是页面定义一个常数）、timestamp（其实也可以常数啦）、url当前页面地址提交给我们最早写的/api/weixin接口，然后将返回的签名提交给wx.config即可。下面的代码可以作为你的模板使用

$(function () {
        var timestamp = Date.parse(new Date())/1000;
        var localurl = encodeURIComponent(window.location.href.split('#')[0]);
        $.ajax({
            url: 'http://www.********.cn/wxapi/api/weixin',
            dataType: "json",
            data: {
                noncestr: 'FFUmZdbWVT9mVP7a',
                timestamp: timestamp,
                url: window.location.href.split('#')[0]
            },
            success: function (data) {
                wxFace(data.toLowerCase());
            }
        })
        function wxFace(signature) {
            wx.config({
                debug: false,
                appId: 'wxec54ec7f720993da',
                timestamp: timestamp,
                nonceStr: 'FFUmZdbWVT9mVP7a',
                signature: signature,
                jsApiList: [
                  'checkJsApi',
                  'onMenuShareTimeline',
                  'onMenuShareAppMessage',
                  'chooseImage',
                  'previewImage',
                  'uploadImage',
                  'downloadImage'
                ]            });
        }
    });


然后我们定义选择图片函数，当选择id="parent1" 、 id="parent2"、id="child"时调用
function chooseUpload(selector) {
    wx.chooseImage({
        success: function (res) {
            $("#loading").show();
            $(function () {
                $.each(res.localIds, function (i, n) {
                    wx.uploadImage({
                    localId: res.localIds.toString(), // 需要上传的图片的本地ID，由chooseImage接口获得
                        isShowProgressTips: 0, // 默认为1，显示进度提示
                        success: function (res1) {
                            $.ajax({
                                url: 'http://www.******.cn/wxapi/face/detect/' + res1.serverId,
                                dataType: "json",
                                success: function (data) {
                                    $("#loading").hide();
                                    if (JSON.parse(data).length == 1) {
                                        $(selector).html('<img src="' + n + '" /> <br />')
                                            .data('faceId', JSON.parse(data)[0].faceId);
                                    } else if (JSON.parse(data).length > 1) {
                                        alert('请选择单人照哦')
                                    } else {
                                        alert('啊，我看不到你的脸~')
                                    }
                                    
                                }
                            })

                        },
                        fail: function (res) {
                            alert(JSON.stringify(res));
                        }
                    });
                });
            });
        }
    });
}

触发点击事件调用上传图片函数
document.querySelector('#parent1').onclick = function () {
    chooseUpload('#parent1')
};
定义函数，将拿到的两张照片的id做对比
  function verify(selector, parent, child) {
      $("#loading").show();
      $.ajax({
          url: 'http://www.******.cn/wxapi/face/verify/' + parent + '/' + child,
         
          dataType: "json",
          success: function (data) {
              $("#loading").hide();
              $(selector).html('相似度：' + (JSON.parse(data).confidence * 100).toFixed(2) + '%')
          }
      })
      
  }

最后是我们分享朋友圈的功能实现。
  var shareData = {
      title: '测测孩子跟谁像',//分享的标题
      desc: '来看看孩子跟爸爸比较像还是跟妈妈比较像',//分享的描述
      link: window.location.href,//分享的快照
      imgUrl: 'http://www. .******.cn/WeFace/fonts/family.jpg'//分享的链接
  };
  wx.onMenuShareAppMessage(shareData);
  wx.onMenuShareTimeline(shareData);

分享结果如图
 
最后再说几句

到目前为止，如何使用APS.NET WebAPI实现微信注入、调用封装微软牛津计划API、使用mongoDB存储数据和客户端如何使用，都已经说清楚了，基本上，你已经可以自己去编写更有价值的应用了。
最后这一章节主要是两个目的，一是感谢二是计划。
我的工作不是做微信应用的，做这个APP纯粹是出于技术人员手痒，在工作之余每天晚上断断续续的编写代码，不但写代码，而且要完成这些文字记录真心是非常考验自己，有相当多次我都感觉自己要放弃了，实在太累了，幸好有如下的朋友一直在鼓励我支持我
	周婷：前端妹子，和我一起研究微信的客户端，帮我调试或者说她更多的承担了客户端的代码
	陈粉琴：这个APP的首席体验官，找BUG、挑不足。
	之颖：台湾妹子，CSDN编辑，一直在鼓励我写下去
	陈秋歌：CSDN编辑、之颖的同事，之颖离职后，就是他一直在鼓励我继续写完
	微软MVP组的紫柔：需要非常感谢的人，在这个项目中提供了我很多便利，关于资料和资源。
如果主编大人能发表这篇文章，且没有删除这章，那我说说之后系列的计划：
牛津计划的免费版在使用的时候有每分钟的请求限制，所以我计划在之后将加入队列和计时器，并且有计划将这个APP放到Azure上，并采用微软的PaaS服务，比如存储和数据库，然后我想对大家使用APP的结果进行BI报表分析和大数据处理等。
好吧，主编大人，这章我可以免费，不算稿费，可以吗？


